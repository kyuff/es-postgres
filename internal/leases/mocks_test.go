// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package leases_test

import (
	"context"
	"github.com/kyuff/es-postgres/internal/dbtx"
	"github.com/kyuff/es-postgres/internal/leases"
	"sync"
	"time"
)

// Ensure, that SchemaMock does implement leases.Schema.
// If this is not the case, regenerate this file with moq.
var _ leases.Schema = &SchemaMock{}

// SchemaMock is a mock implementation of leases.Schema.
//
//	func TestSomethingThatUsesSchema(t *testing.T) {
//
//		// make and configure a mocked leases.Schema
//		mockedSchema := &SchemaMock{
//			ApproveLeaseFunc: func(ctx context.Context, db dbtx.DBTX, vnodes []uint32) error {
//				panic("mock out the ApproveLease method")
//			},
//			InsertLeaseFunc: func(ctx context.Context, db dbtx.DBTX, vnode uint32, name string, ttl time.Duration, status string) error {
//				panic("mock out the InsertLease method")
//			},
//			SelectLeasesFunc: func(ctx context.Context, db dbtx.DBTX) (leases.Ring, error) {
//				panic("mock out the SelectLeases method")
//			},
//		}
//
//		// use mockedSchema in code that requires leases.Schema
//		// and then make assertions.
//
//	}
type SchemaMock struct {
	// ApproveLeaseFunc mocks the ApproveLease method.
	ApproveLeaseFunc func(ctx context.Context, db dbtx.DBTX, vnodes []uint32) error

	// InsertLeaseFunc mocks the InsertLease method.
	InsertLeaseFunc func(ctx context.Context, db dbtx.DBTX, vnode uint32, name string, ttl time.Duration, status string) error

	// SelectLeasesFunc mocks the SelectLeases method.
	SelectLeasesFunc func(ctx context.Context, db dbtx.DBTX) (leases.Ring, error)

	// calls tracks calls to the methods.
	calls struct {
		// ApproveLease holds details about calls to the ApproveLease method.
		ApproveLease []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db dbtx.DBTX
			// Vnodes is the vnodes argument value.
			Vnodes []uint32
		}
		// InsertLease holds details about calls to the InsertLease method.
		InsertLease []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db dbtx.DBTX
			// Vnode is the vnode argument value.
			Vnode uint32
			// Name is the name argument value.
			Name string
			// LeaseTTL is the ttl argument value.
			TTL time.Duration
			// Status is the status argument value.
			Status string
		}
		// SelectLeases holds details about calls to the SelectLeases method.
		SelectLeases []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db dbtx.DBTX
		}
	}
	lockApproveLease sync.RWMutex
	lockInsertLease  sync.RWMutex
	lockSelectLeases sync.RWMutex
}

// ApproveLease calls ApproveLeaseFunc.
func (mock *SchemaMock) ApproveLease(ctx context.Context, db dbtx.DBTX, vnodes []uint32) error {
	if mock.ApproveLeaseFunc == nil {
		panic("SchemaMock.ApproveLeaseFunc: method is nil but Schema.ApproveLease was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Db     dbtx.DBTX
		Vnodes []uint32
	}{
		Ctx:    ctx,
		Db:     db,
		Vnodes: vnodes,
	}
	mock.lockApproveLease.Lock()
	mock.calls.ApproveLease = append(mock.calls.ApproveLease, callInfo)
	mock.lockApproveLease.Unlock()
	return mock.ApproveLeaseFunc(ctx, db, vnodes)
}

// ApproveLeaseCalls gets all the calls that were made to ApproveLease.
// Check the length with:
//
//	len(mockedSchema.ApproveLeaseCalls())
func (mock *SchemaMock) ApproveLeaseCalls() []struct {
	Ctx    context.Context
	Db     dbtx.DBTX
	Vnodes []uint32
} {
	var calls []struct {
		Ctx    context.Context
		Db     dbtx.DBTX
		Vnodes []uint32
	}
	mock.lockApproveLease.RLock()
	calls = mock.calls.ApproveLease
	mock.lockApproveLease.RUnlock()
	return calls
}

// InsertLease calls InsertLeaseFunc.
func (mock *SchemaMock) InsertLease(ctx context.Context, db dbtx.DBTX, vnode uint32, name string, ttl time.Duration, status string) error {
	if mock.InsertLeaseFunc == nil {
		panic("SchemaMock.InsertLeaseFunc: method is nil but Schema.InsertLease was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Db     dbtx.DBTX
		Vnode  uint32
		Name   string
		TTL    time.Duration
		Status string
	}{
		Ctx:    ctx,
		Db:     db,
		Vnode:  vnode,
		Name:   name,
		TTL:    ttl,
		Status: status,
	}
	mock.lockInsertLease.Lock()
	mock.calls.InsertLease = append(mock.calls.InsertLease, callInfo)
	mock.lockInsertLease.Unlock()
	return mock.InsertLeaseFunc(ctx, db, vnode, name, ttl, status)
}

// InsertLeaseCalls gets all the calls that were made to InsertLease.
// Check the length with:
//
//	len(mockedSchema.InsertLeaseCalls())
func (mock *SchemaMock) InsertLeaseCalls() []struct {
	Ctx    context.Context
	Db     dbtx.DBTX
	Vnode  uint32
	Name   string
	TTL    time.Duration
	Status string
} {
	var calls []struct {
		Ctx    context.Context
		Db     dbtx.DBTX
		Vnode  uint32
		Name   string
		TTL    time.Duration
		Status string
	}
	mock.lockInsertLease.RLock()
	calls = mock.calls.InsertLease
	mock.lockInsertLease.RUnlock()
	return calls
}

// SelectLeases calls SelectLeasesFunc.
func (mock *SchemaMock) SelectLeases(ctx context.Context, db dbtx.DBTX) (leases.Ring, error) {
	if mock.SelectLeasesFunc == nil {
		panic("SchemaMock.SelectLeasesFunc: method is nil but Schema.SelectLeases was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Db  dbtx.DBTX
	}{
		Ctx: ctx,
		Db:  db,
	}
	mock.lockSelectLeases.Lock()
	mock.calls.SelectLeases = append(mock.calls.SelectLeases, callInfo)
	mock.lockSelectLeases.Unlock()
	return mock.SelectLeasesFunc(ctx, db)
}

// SelectLeasesCalls gets all the calls that were made to SelectLeases.
// Check the length with:
//
//	len(mockedSchema.SelectLeasesCalls())
func (mock *SchemaMock) SelectLeasesCalls() []struct {
	Ctx context.Context
	Db  dbtx.DBTX
} {
	var calls []struct {
		Ctx context.Context
		Db  dbtx.DBTX
	}
	mock.lockSelectLeases.RLock()
	calls = mock.calls.SelectLeases
	mock.lockSelectLeases.RUnlock()
	return calls
}
