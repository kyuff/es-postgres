// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package leases_test

import (
	"context"
	"github.com/kyuff/es-postgres/internal/dbtx"
	"github.com/kyuff/es-postgres/internal/leases"
	"sync"
	"time"
)

// Ensure, that SchemaMock does implement leases.Schema.
// If this is not the case, regenerate this file with moq.
var _ leases.Schema = &SchemaMock{}

// SchemaMock is a mock implementation of leases.Schema.
//
//	func TestSomethingThatUsesSchema(t *testing.T) {
//
//		// make and configure a mocked leases.Schema
//		mockedSchema := &SchemaMock{
//			ApproveLeaseFunc: func(ctx context.Context, db dbtx.DBTX, vnodes []uint32) error {
//				panic("mock out the ApproveLease method")
//			},
//			InsertLeaseFunc: func(ctx context.Context, db dbtx.DBTX, vnode uint32, name string, ttl time.Duration, status string) error {
//				panic("mock out the InsertLease method")
//			},
//			RefreshLeasesFunc: func(ctx context.Context, db dbtx.DBTX, nodeName string, ttl time.Duration) (leases.Ring, error) {
//				panic("mock out the RefreshLeases method")
//			},
//		}
//
//		// use mockedSchema in code that requires leases.Schema
//		// and then make assertions.
//
//	}
type SchemaMock struct {
	// ApproveLeaseFunc mocks the ApproveLease method.
	ApproveLeaseFunc func(ctx context.Context, db dbtx.DBTX, vnodes []uint32) error

	// InsertLeaseFunc mocks the InsertLease method.
	InsertLeaseFunc func(ctx context.Context, db dbtx.DBTX, vnode uint32, name string, ttl time.Duration, status string) error

	// RefreshLeasesFunc mocks the RefreshLeases method.
	RefreshLeasesFunc func(ctx context.Context, db dbtx.DBTX, nodeName string, ttl time.Duration) (leases.Ring, error)

	// calls tracks calls to the methods.
	calls struct {
		// ApproveLease holds details about calls to the ApproveLease method.
		ApproveLease []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db dbtx.DBTX
			// Vnodes is the vnodes argument value.
			Vnodes []uint32
		}
		// InsertLease holds details about calls to the InsertLease method.
		InsertLease []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db dbtx.DBTX
			// Vnode is the vnode argument value.
			Vnode uint32
			// Name is the name argument value.
			Name string
			// TTL is the ttl argument value.
			TTL time.Duration
			// Status is the status argument value.
			Status string
		}
		// RefreshLeases holds details about calls to the RefreshLeases method.
		RefreshLeases []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db dbtx.DBTX
			// NodeName is the nodeName argument value.
			NodeName string
			// TTL is the ttl argument value.
			TTL time.Duration
		}
	}
	lockApproveLease  sync.RWMutex
	lockInsertLease   sync.RWMutex
	lockRefreshLeases sync.RWMutex
}

// ApproveLease calls ApproveLeaseFunc.
func (mock *SchemaMock) ApproveLease(ctx context.Context, db dbtx.DBTX, vnodes []uint32) error {
	if mock.ApproveLeaseFunc == nil {
		panic("SchemaMock.ApproveLeaseFunc: method is nil but Schema.ApproveLease was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Db     dbtx.DBTX
		Vnodes []uint32
	}{
		Ctx:    ctx,
		Db:     db,
		Vnodes: vnodes,
	}
	mock.lockApproveLease.Lock()
	mock.calls.ApproveLease = append(mock.calls.ApproveLease, callInfo)
	mock.lockApproveLease.Unlock()
	return mock.ApproveLeaseFunc(ctx, db, vnodes)
}

// ApproveLeaseCalls gets all the calls that were made to ApproveLease.
// Check the length with:
//
//	len(mockedSchema.ApproveLeaseCalls())
func (mock *SchemaMock) ApproveLeaseCalls() []struct {
	Ctx    context.Context
	Db     dbtx.DBTX
	Vnodes []uint32
} {
	var calls []struct {
		Ctx    context.Context
		Db     dbtx.DBTX
		Vnodes []uint32
	}
	mock.lockApproveLease.RLock()
	calls = mock.calls.ApproveLease
	mock.lockApproveLease.RUnlock()
	return calls
}

// InsertLease calls InsertLeaseFunc.
func (mock *SchemaMock) InsertLease(ctx context.Context, db dbtx.DBTX, vnode uint32, name string, ttl time.Duration, status string) error {
	if mock.InsertLeaseFunc == nil {
		panic("SchemaMock.InsertLeaseFunc: method is nil but Schema.InsertLease was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Db     dbtx.DBTX
		Vnode  uint32
		Name   string
		TTL    time.Duration
		Status string
	}{
		Ctx:    ctx,
		Db:     db,
		Vnode:  vnode,
		Name:   name,
		TTL:    ttl,
		Status: status,
	}
	mock.lockInsertLease.Lock()
	mock.calls.InsertLease = append(mock.calls.InsertLease, callInfo)
	mock.lockInsertLease.Unlock()
	return mock.InsertLeaseFunc(ctx, db, vnode, name, ttl, status)
}

// InsertLeaseCalls gets all the calls that were made to InsertLease.
// Check the length with:
//
//	len(mockedSchema.InsertLeaseCalls())
func (mock *SchemaMock) InsertLeaseCalls() []struct {
	Ctx    context.Context
	Db     dbtx.DBTX
	Vnode  uint32
	Name   string
	TTL    time.Duration
	Status string
} {
	var calls []struct {
		Ctx    context.Context
		Db     dbtx.DBTX
		Vnode  uint32
		Name   string
		TTL    time.Duration
		Status string
	}
	mock.lockInsertLease.RLock()
	calls = mock.calls.InsertLease
	mock.lockInsertLease.RUnlock()
	return calls
}

// RefreshLeases calls RefreshLeasesFunc.
func (mock *SchemaMock) RefreshLeases(ctx context.Context, db dbtx.DBTX, nodeName string, ttl time.Duration) (leases.Ring, error) {
	if mock.RefreshLeasesFunc == nil {
		panic("SchemaMock.RefreshLeasesFunc: method is nil but Schema.RefreshLeases was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Db       dbtx.DBTX
		NodeName string
		TTL      time.Duration
	}{
		Ctx:      ctx,
		Db:       db,
		NodeName: nodeName,
		TTL:      ttl,
	}
	mock.lockRefreshLeases.Lock()
	mock.calls.RefreshLeases = append(mock.calls.RefreshLeases, callInfo)
	mock.lockRefreshLeases.Unlock()
	return mock.RefreshLeasesFunc(ctx, db, nodeName, ttl)
}

// RefreshLeasesCalls gets all the calls that were made to RefreshLeases.
// Check the length with:
//
//	len(mockedSchema.RefreshLeasesCalls())
func (mock *SchemaMock) RefreshLeasesCalls() []struct {
	Ctx      context.Context
	Db       dbtx.DBTX
	NodeName string
	TTL      time.Duration
} {
	var calls []struct {
		Ctx      context.Context
		Db       dbtx.DBTX
		NodeName string
		TTL      time.Duration
	}
	mock.lockRefreshLeases.RLock()
	calls = mock.calls.RefreshLeases
	mock.lockRefreshLeases.RUnlock()
	return calls
}
