// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package leases_test

import (
	"context"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/kyuff/es-postgres/internal/dbtx"
	"github.com/kyuff/es-postgres/internal/leases"
	"sync"
	"time"
)

// Ensure, that SchemaMock does implement leases.Schema.
// If this is not the case, regenerate this file with moq.
var _ leases.Schema = &SchemaMock{}

// SchemaMock is a mock implementation of leases.Schema.
//
//	func TestSomethingThatUsesSchema(t *testing.T) {
//
//		// make and configure a mocked leases.Schema
//		mockedSchema := &SchemaMock{
//			ApproveLeaseFunc: func(ctx context.Context, db dbtx.DBTX, vnodes []uint32) error {
//				panic("mock out the ApproveLease method")
//			},
//			InsertLeaseFunc: func(ctx context.Context, db dbtx.DBTX, vnode uint32, name string, ttl time.Duration, status string) error {
//				panic("mock out the InsertLease method")
//			},
//			RefreshLeasesFunc: func(ctx context.Context, db dbtx.DBTX, nodeName string, ttl time.Duration) (leases.Ring, error) {
//				panic("mock out the RefreshLeases method")
//			},
//		}
//
//		// use mockedSchema in code that requires leases.Schema
//		// and then make assertions.
//
//	}
type SchemaMock struct {
	// ApproveLeaseFunc mocks the ApproveLease method.
	ApproveLeaseFunc func(ctx context.Context, db dbtx.DBTX, vnodes []uint32) error

	// InsertLeaseFunc mocks the InsertLease method.
	InsertLeaseFunc func(ctx context.Context, db dbtx.DBTX, vnode uint32, name string, ttl time.Duration, status string) error

	// RefreshLeasesFunc mocks the RefreshLeases method.
	RefreshLeasesFunc func(ctx context.Context, db dbtx.DBTX, nodeName string, ttl time.Duration) (leases.Ring, error)

	// calls tracks calls to the methods.
	calls struct {
		// ApproveLease holds details about calls to the ApproveLease method.
		ApproveLease []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db dbtx.DBTX
			// Vnodes is the vnodes argument value.
			Vnodes []uint32
		}
		// InsertLease holds details about calls to the InsertLease method.
		InsertLease []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db dbtx.DBTX
			// Vnode is the vnode argument value.
			Vnode uint32
			// Name is the name argument value.
			Name string
			// TTL is the ttl argument value.
			TTL time.Duration
			// Status is the status argument value.
			Status string
		}
		// RefreshLeases holds details about calls to the RefreshLeases method.
		RefreshLeases []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db dbtx.DBTX
			// NodeName is the nodeName argument value.
			NodeName string
			// TTL is the ttl argument value.
			TTL time.Duration
		}
	}
	lockApproveLease  sync.RWMutex
	lockInsertLease   sync.RWMutex
	lockRefreshLeases sync.RWMutex
}

// ApproveLease calls ApproveLeaseFunc.
func (mock *SchemaMock) ApproveLease(ctx context.Context, db dbtx.DBTX, vnodes []uint32) error {
	if mock.ApproveLeaseFunc == nil {
		panic("SchemaMock.ApproveLeaseFunc: method is nil but Schema.ApproveLease was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Db     dbtx.DBTX
		Vnodes []uint32
	}{
		Ctx:    ctx,
		Db:     db,
		Vnodes: vnodes,
	}
	mock.lockApproveLease.Lock()
	mock.calls.ApproveLease = append(mock.calls.ApproveLease, callInfo)
	mock.lockApproveLease.Unlock()
	return mock.ApproveLeaseFunc(ctx, db, vnodes)
}

// ApproveLeaseCalls gets all the calls that were made to ApproveLease.
// Check the length with:
//
//	len(mockedSchema.ApproveLeaseCalls())
func (mock *SchemaMock) ApproveLeaseCalls() []struct {
	Ctx    context.Context
	Db     dbtx.DBTX
	Vnodes []uint32
} {
	var calls []struct {
		Ctx    context.Context
		Db     dbtx.DBTX
		Vnodes []uint32
	}
	mock.lockApproveLease.RLock()
	calls = mock.calls.ApproveLease
	mock.lockApproveLease.RUnlock()
	return calls
}

// InsertLease calls InsertLeaseFunc.
func (mock *SchemaMock) InsertLease(ctx context.Context, db dbtx.DBTX, vnode uint32, name string, ttl time.Duration, status string) error {
	if mock.InsertLeaseFunc == nil {
		panic("SchemaMock.InsertLeaseFunc: method is nil but Schema.InsertLease was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Db     dbtx.DBTX
		Vnode  uint32
		Name   string
		TTL    time.Duration
		Status string
	}{
		Ctx:    ctx,
		Db:     db,
		Vnode:  vnode,
		Name:   name,
		TTL:    ttl,
		Status: status,
	}
	mock.lockInsertLease.Lock()
	mock.calls.InsertLease = append(mock.calls.InsertLease, callInfo)
	mock.lockInsertLease.Unlock()
	return mock.InsertLeaseFunc(ctx, db, vnode, name, ttl, status)
}

// InsertLeaseCalls gets all the calls that were made to InsertLease.
// Check the length with:
//
//	len(mockedSchema.InsertLeaseCalls())
func (mock *SchemaMock) InsertLeaseCalls() []struct {
	Ctx    context.Context
	Db     dbtx.DBTX
	Vnode  uint32
	Name   string
	TTL    time.Duration
	Status string
} {
	var calls []struct {
		Ctx    context.Context
		Db     dbtx.DBTX
		Vnode  uint32
		Name   string
		TTL    time.Duration
		Status string
	}
	mock.lockInsertLease.RLock()
	calls = mock.calls.InsertLease
	mock.lockInsertLease.RUnlock()
	return calls
}

// RefreshLeases calls RefreshLeasesFunc.
func (mock *SchemaMock) RefreshLeases(ctx context.Context, db dbtx.DBTX, nodeName string, ttl time.Duration) (leases.Ring, error) {
	if mock.RefreshLeasesFunc == nil {
		panic("SchemaMock.RefreshLeasesFunc: method is nil but Schema.RefreshLeases was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Db       dbtx.DBTX
		NodeName string
		TTL      time.Duration
	}{
		Ctx:      ctx,
		Db:       db,
		NodeName: nodeName,
		TTL:      ttl,
	}
	mock.lockRefreshLeases.Lock()
	mock.calls.RefreshLeases = append(mock.calls.RefreshLeases, callInfo)
	mock.lockRefreshLeases.Unlock()
	return mock.RefreshLeasesFunc(ctx, db, nodeName, ttl)
}

// RefreshLeasesCalls gets all the calls that were made to RefreshLeases.
// Check the length with:
//
//	len(mockedSchema.RefreshLeasesCalls())
func (mock *SchemaMock) RefreshLeasesCalls() []struct {
	Ctx      context.Context
	Db       dbtx.DBTX
	NodeName string
	TTL      time.Duration
} {
	var calls []struct {
		Ctx      context.Context
		Db       dbtx.DBTX
		NodeName string
		TTL      time.Duration
	}
	mock.lockRefreshLeases.RLock()
	calls = mock.calls.RefreshLeases
	mock.lockRefreshLeases.RUnlock()
	return calls
}

// Ensure, that HeartbeaterMock does implement leases.Heartbeater.
// If this is not the case, regenerate this file with moq.
var _ leases.Heartbeater = &HeartbeaterMock{}

// HeartbeaterMock is a mock implementation of leases.Heartbeater.
//
//	func TestSomethingThatUsesHeartbeater(t *testing.T) {
//
//		// make and configure a mocked leases.Heartbeater
//		mockedHeartbeater := &HeartbeaterMock{
//			HeartbeatFunc: func(ctx context.Context, conn dbtx.DBTX) ([]uint32, error) {
//				panic("mock out the Heartbeat method")
//			},
//		}
//
//		// use mockedHeartbeater in code that requires leases.Heartbeater
//		// and then make assertions.
//
//	}
type HeartbeaterMock struct {
	// HeartbeatFunc mocks the Heartbeat method.
	HeartbeatFunc func(ctx context.Context, conn dbtx.DBTX) ([]uint32, error)

	// calls tracks calls to the methods.
	calls struct {
		// Heartbeat holds details about calls to the Heartbeat method.
		Heartbeat []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Conn is the conn argument value.
			Conn dbtx.DBTX
		}
	}
	lockHeartbeat sync.RWMutex
}

// Heartbeat calls HeartbeatFunc.
func (mock *HeartbeaterMock) Heartbeat(ctx context.Context, conn dbtx.DBTX) ([]uint32, error) {
	if mock.HeartbeatFunc == nil {
		panic("HeartbeaterMock.HeartbeatFunc: method is nil but Heartbeater.Heartbeat was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Conn dbtx.DBTX
	}{
		Ctx:  ctx,
		Conn: conn,
	}
	mock.lockHeartbeat.Lock()
	mock.calls.Heartbeat = append(mock.calls.Heartbeat, callInfo)
	mock.lockHeartbeat.Unlock()
	return mock.HeartbeatFunc(ctx, conn)
}

// HeartbeatCalls gets all the calls that were made to Heartbeat.
// Check the length with:
//
//	len(mockedHeartbeater.HeartbeatCalls())
func (mock *HeartbeaterMock) HeartbeatCalls() []struct {
	Ctx  context.Context
	Conn dbtx.DBTX
} {
	var calls []struct {
		Ctx  context.Context
		Conn dbtx.DBTX
	}
	mock.lockHeartbeat.RLock()
	calls = mock.calls.Heartbeat
	mock.lockHeartbeat.RUnlock()
	return calls
}

// Ensure, that ConnectorMock does implement leases.Connector.
// If this is not the case, regenerate this file with moq.
var _ leases.Connector = &ConnectorMock{}

// ConnectorMock is a mock implementation of leases.Connector.
//
//	func TestSomethingThatUsesConnector(t *testing.T) {
//
//		// make and configure a mocked leases.Connector
//		mockedConnector := &ConnectorMock{
//			AcquireWriteFunc: func(ctx context.Context) (*pgxpool.Conn, error) {
//				panic("mock out the AcquireWrite method")
//			},
//		}
//
//		// use mockedConnector in code that requires leases.Connector
//		// and then make assertions.
//
//	}
type ConnectorMock struct {
	// AcquireWriteFunc mocks the AcquireWrite method.
	AcquireWriteFunc func(ctx context.Context) (*pgxpool.Conn, error)

	// calls tracks calls to the methods.
	calls struct {
		// AcquireWrite holds details about calls to the AcquireWrite method.
		AcquireWrite []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockAcquireWrite sync.RWMutex
}

// AcquireWrite calls AcquireWriteFunc.
func (mock *ConnectorMock) AcquireWrite(ctx context.Context) (*pgxpool.Conn, error) {
	if mock.AcquireWriteFunc == nil {
		panic("ConnectorMock.AcquireWriteFunc: method is nil but Connector.AcquireWrite was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockAcquireWrite.Lock()
	mock.calls.AcquireWrite = append(mock.calls.AcquireWrite, callInfo)
	mock.lockAcquireWrite.Unlock()
	return mock.AcquireWriteFunc(ctx)
}

// AcquireWriteCalls gets all the calls that were made to AcquireWrite.
// Check the length with:
//
//	len(mockedConnector.AcquireWriteCalls())
func (mock *ConnectorMock) AcquireWriteCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockAcquireWrite.RLock()
	calls = mock.calls.AcquireWrite
	mock.lockAcquireWrite.RUnlock()
	return calls
}
