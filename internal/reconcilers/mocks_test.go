// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package reconcilers_test

import (
	"context"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/kyuff/es"
	"github.com/kyuff/es-postgres/internal/dbtx"
	"github.com/kyuff/es-postgres/internal/reconcilers"
	"sync"
	"time"
)

// Ensure, that ValuerMock does implement reconcilers.Valuer.
// If this is not the case, regenerate this file with moq.
var _ reconcilers.Valuer = &ValuerMock{}

// ValuerMock is a mock implementation of reconcilers.Valuer.
//
//	func TestSomethingThatUsesValuer(t *testing.T) {
//
//		// make and configure a mocked reconcilers.Valuer
//		mockedValuer := &ValuerMock{
//			ValuesFunc: func() []uint32 {
//				panic("mock out the Values method")
//			},
//		}
//
//		// use mockedValuer in code that requires reconcilers.Valuer
//		// and then make assertions.
//
//	}
type ValuerMock struct {
	// ValuesFunc mocks the Values method.
	ValuesFunc func() []uint32

	// calls tracks calls to the methods.
	calls struct {
		// Values holds details about calls to the Values method.
		Values []struct {
		}
	}
	lockValues sync.RWMutex
}

// Values calls ValuesFunc.
func (mock *ValuerMock) Values() []uint32 {
	if mock.ValuesFunc == nil {
		panic("ValuerMock.ValuesFunc: method is nil but Valuer.Values was just called")
	}
	callInfo := struct {
	}{}
	mock.lockValues.Lock()
	mock.calls.Values = append(mock.calls.Values, callInfo)
	mock.lockValues.Unlock()
	return mock.ValuesFunc()
}

// ValuesCalls gets all the calls that were made to Values.
// Check the length with:
//
//	len(mockedValuer.ValuesCalls())
func (mock *ValuerMock) ValuesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockValues.RLock()
	calls = mock.calls.Values
	mock.lockValues.RUnlock()
	return calls
}

// Ensure, that ConnectorMock does implement reconcilers.Connector.
// If this is not the case, regenerate this file with moq.
var _ reconcilers.Connector = &ConnectorMock{}

// ConnectorMock is a mock implementation of reconcilers.Connector.
//
//	func TestSomethingThatUsesConnector(t *testing.T) {
//
//		// make and configure a mocked reconcilers.Connector
//		mockedConnector := &ConnectorMock{
//			AcquireReadFunc: func(ctx context.Context) (*pgxpool.Conn, error) {
//				panic("mock out the AcquireRead method")
//			},
//			AcquireWriteFunc: func(ctx context.Context) (*pgxpool.Conn, error) {
//				panic("mock out the AcquireWrite method")
//			},
//		}
//
//		// use mockedConnector in code that requires reconcilers.Connector
//		// and then make assertions.
//
//	}
type ConnectorMock struct {
	// AcquireReadFunc mocks the AcquireRead method.
	AcquireReadFunc func(ctx context.Context) (*pgxpool.Conn, error)

	// AcquireWriteFunc mocks the AcquireWrite method.
	AcquireWriteFunc func(ctx context.Context) (*pgxpool.Conn, error)

	// calls tracks calls to the methods.
	calls struct {
		// AcquireRead holds details about calls to the AcquireRead method.
		AcquireRead []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// AcquireWrite holds details about calls to the AcquireWrite method.
		AcquireWrite []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockAcquireRead  sync.RWMutex
	lockAcquireWrite sync.RWMutex
}

// AcquireRead calls AcquireReadFunc.
func (mock *ConnectorMock) AcquireRead(ctx context.Context) (*pgxpool.Conn, error) {
	if mock.AcquireReadFunc == nil {
		panic("ConnectorMock.AcquireReadFunc: method is nil but Connector.AcquireRead was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockAcquireRead.Lock()
	mock.calls.AcquireRead = append(mock.calls.AcquireRead, callInfo)
	mock.lockAcquireRead.Unlock()
	return mock.AcquireReadFunc(ctx)
}

// AcquireReadCalls gets all the calls that were made to AcquireRead.
// Check the length with:
//
//	len(mockedConnector.AcquireReadCalls())
func (mock *ConnectorMock) AcquireReadCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockAcquireRead.RLock()
	calls = mock.calls.AcquireRead
	mock.lockAcquireRead.RUnlock()
	return calls
}

// AcquireWrite calls AcquireWriteFunc.
func (mock *ConnectorMock) AcquireWrite(ctx context.Context) (*pgxpool.Conn, error) {
	if mock.AcquireWriteFunc == nil {
		panic("ConnectorMock.AcquireWriteFunc: method is nil but Connector.AcquireWrite was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockAcquireWrite.Lock()
	mock.calls.AcquireWrite = append(mock.calls.AcquireWrite, callInfo)
	mock.lockAcquireWrite.Unlock()
	return mock.AcquireWriteFunc(ctx)
}

// AcquireWriteCalls gets all the calls that were made to AcquireWrite.
// Check the length with:
//
//	len(mockedConnector.AcquireWriteCalls())
func (mock *ConnectorMock) AcquireWriteCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockAcquireWrite.RLock()
	calls = mock.calls.AcquireWrite
	mock.lockAcquireWrite.RUnlock()
	return calls
}

// Ensure, that SchemaMock does implement reconcilers.Schema.
// If this is not the case, regenerate this file with moq.
var _ reconcilers.Schema = &SchemaMock{}

// SchemaMock is a mock implementation of reconcilers.Schema.
//
//	func TestSomethingThatUsesSchema(t *testing.T) {
//
//		// make and configure a mocked reconcilers.Schema
//		mockedSchema := &SchemaMock{
//			ListenFunc: func(ctx context.Context, db dbtx.DBTX, partitions []uint32) error {
//				panic("mock out the Listen method")
//			},
//			SelectOutboxStreamIDsFunc: func(ctx context.Context, db dbtx.DBTX, graceWindow time.Duration, partitions []uint32, token string, limit int) ([]es.StreamReference, error) {
//				panic("mock out the SelectOutboxStreamIDs method")
//			},
//			UnlistenFunc: func(ctx context.Context, db dbtx.DBTX, partitions []uint32) error {
//				panic("mock out the Unlisten method")
//			},
//		}
//
//		// use mockedSchema in code that requires reconcilers.Schema
//		// and then make assertions.
//
//	}
type SchemaMock struct {
	// ListenFunc mocks the Listen method.
	ListenFunc func(ctx context.Context, db dbtx.DBTX, partitions []uint32) error

	// SelectOutboxStreamIDsFunc mocks the SelectOutboxStreamIDs method.
	SelectOutboxStreamIDsFunc func(ctx context.Context, db dbtx.DBTX, graceWindow time.Duration, partitions []uint32, token string, limit int) ([]es.StreamReference, error)

	// UnlistenFunc mocks the Unlisten method.
	UnlistenFunc func(ctx context.Context, db dbtx.DBTX, partitions []uint32) error

	// calls tracks calls to the methods.
	calls struct {
		// Listen holds details about calls to the Listen method.
		Listen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db dbtx.DBTX
			// Partitions is the partitions argument value.
			Partitions []uint32
		}
		// SelectOutboxStreamIDs holds details about calls to the SelectOutboxStreamIDs method.
		SelectOutboxStreamIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db dbtx.DBTX
			// GraceWindow is the graceWindow argument value.
			GraceWindow time.Duration
			// Partitions is the partitions argument value.
			Partitions []uint32
			// Token is the token argument value.
			Token string
			// Limit is the limit argument value.
			Limit int
		}
		// Unlisten holds details about calls to the Unlisten method.
		Unlisten []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db dbtx.DBTX
			// Partitions is the partitions argument value.
			Partitions []uint32
		}
	}
	lockListen                sync.RWMutex
	lockSelectOutboxStreamIDs sync.RWMutex
	lockUnlisten              sync.RWMutex
}

// Listen calls ListenFunc.
func (mock *SchemaMock) Listen(ctx context.Context, db dbtx.DBTX, partitions []uint32) error {
	if mock.ListenFunc == nil {
		panic("SchemaMock.ListenFunc: method is nil but Schema.Listen was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Db         dbtx.DBTX
		Partitions []uint32
	}{
		Ctx:        ctx,
		Db:         db,
		Partitions: partitions,
	}
	mock.lockListen.Lock()
	mock.calls.Listen = append(mock.calls.Listen, callInfo)
	mock.lockListen.Unlock()
	return mock.ListenFunc(ctx, db, partitions)
}

// ListenCalls gets all the calls that were made to Listen.
// Check the length with:
//
//	len(mockedSchema.ListenCalls())
func (mock *SchemaMock) ListenCalls() []struct {
	Ctx        context.Context
	Db         dbtx.DBTX
	Partitions []uint32
} {
	var calls []struct {
		Ctx        context.Context
		Db         dbtx.DBTX
		Partitions []uint32
	}
	mock.lockListen.RLock()
	calls = mock.calls.Listen
	mock.lockListen.RUnlock()
	return calls
}

// SelectOutboxStreamIDs calls SelectOutboxStreamIDsFunc.
func (mock *SchemaMock) SelectOutboxStreamIDs(ctx context.Context, db dbtx.DBTX, graceWindow time.Duration, partitions []uint32, token string, limit int) ([]es.StreamReference, error) {
	if mock.SelectOutboxStreamIDsFunc == nil {
		panic("SchemaMock.SelectOutboxStreamIDsFunc: method is nil but Schema.SelectOutboxStreamIDs was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Db          dbtx.DBTX
		GraceWindow time.Duration
		Partitions  []uint32
		Token       string
		Limit       int
	}{
		Ctx:         ctx,
		Db:          db,
		GraceWindow: graceWindow,
		Partitions:  partitions,
		Token:       token,
		Limit:       limit,
	}
	mock.lockSelectOutboxStreamIDs.Lock()
	mock.calls.SelectOutboxStreamIDs = append(mock.calls.SelectOutboxStreamIDs, callInfo)
	mock.lockSelectOutboxStreamIDs.Unlock()
	return mock.SelectOutboxStreamIDsFunc(ctx, db, graceWindow, partitions, token, limit)
}

// SelectOutboxStreamIDsCalls gets all the calls that were made to SelectOutboxStreamIDs.
// Check the length with:
//
//	len(mockedSchema.SelectOutboxStreamIDsCalls())
func (mock *SchemaMock) SelectOutboxStreamIDsCalls() []struct {
	Ctx         context.Context
	Db          dbtx.DBTX
	GraceWindow time.Duration
	Partitions  []uint32
	Token       string
	Limit       int
} {
	var calls []struct {
		Ctx         context.Context
		Db          dbtx.DBTX
		GraceWindow time.Duration
		Partitions  []uint32
		Token       string
		Limit       int
	}
	mock.lockSelectOutboxStreamIDs.RLock()
	calls = mock.calls.SelectOutboxStreamIDs
	mock.lockSelectOutboxStreamIDs.RUnlock()
	return calls
}

// Unlisten calls UnlistenFunc.
func (mock *SchemaMock) Unlisten(ctx context.Context, db dbtx.DBTX, partitions []uint32) error {
	if mock.UnlistenFunc == nil {
		panic("SchemaMock.UnlistenFunc: method is nil but Schema.Unlisten was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Db         dbtx.DBTX
		Partitions []uint32
	}{
		Ctx:        ctx,
		Db:         db,
		Partitions: partitions,
	}
	mock.lockUnlisten.Lock()
	mock.calls.Unlisten = append(mock.calls.Unlisten, callInfo)
	mock.lockUnlisten.Unlock()
	return mock.UnlistenFunc(ctx, db, partitions)
}

// UnlistenCalls gets all the calls that were made to Unlisten.
// Check the length with:
//
//	len(mockedSchema.UnlistenCalls())
func (mock *SchemaMock) UnlistenCalls() []struct {
	Ctx        context.Context
	Db         dbtx.DBTX
	Partitions []uint32
} {
	var calls []struct {
		Ctx        context.Context
		Db         dbtx.DBTX
		Partitions []uint32
	}
	mock.lockUnlisten.RLock()
	calls = mock.calls.Unlisten
	mock.lockUnlisten.RUnlock()
	return calls
}

// Ensure, that ProcessorMock does implement reconcilers.Processor.
// If this is not the case, regenerate this file with moq.
var _ reconcilers.Processor = &ProcessorMock{}

// ProcessorMock is a mock implementation of reconcilers.Processor.
//
//	func TestSomethingThatUsesProcessor(t *testing.T) {
//
//		// make and configure a mocked reconcilers.Processor
//		mockedProcessor := &ProcessorMock{
//			ProcessFunc: func(ctx context.Context, stream es.StreamReference) error {
//				panic("mock out the Process method")
//			},
//		}
//
//		// use mockedProcessor in code that requires reconcilers.Processor
//		// and then make assertions.
//
//	}
type ProcessorMock struct {
	// ProcessFunc mocks the Process method.
	ProcessFunc func(ctx context.Context, stream es.StreamReference) error

	// calls tracks calls to the methods.
	calls struct {
		// Process holds details about calls to the Process method.
		Process []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream es.StreamReference
		}
	}
	lockProcess sync.RWMutex
}

// Process calls ProcessFunc.
func (mock *ProcessorMock) Process(ctx context.Context, stream es.StreamReference) error {
	if mock.ProcessFunc == nil {
		panic("ProcessorMock.ProcessFunc: method is nil but Processor.Process was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream es.StreamReference
	}{
		Ctx:    ctx,
		Stream: stream,
	}
	mock.lockProcess.Lock()
	mock.calls.Process = append(mock.calls.Process, callInfo)
	mock.lockProcess.Unlock()
	return mock.ProcessFunc(ctx, stream)
}

// ProcessCalls gets all the calls that were made to Process.
// Check the length with:
//
//	len(mockedProcessor.ProcessCalls())
func (mock *ProcessorMock) ProcessCalls() []struct {
	Ctx    context.Context
	Stream es.StreamReference
} {
	var calls []struct {
		Ctx    context.Context
		Stream es.StreamReference
	}
	mock.lockProcess.RLock()
	calls = mock.calls.Process
	mock.lockProcess.RUnlock()
	return calls
}

// Ensure, that ReconcilerMock does implement reconcilers.Reconciler.
// If this is not the case, regenerate this file with moq.
var _ reconcilers.Reconciler = &ReconcilerMock{}

// ReconcilerMock is a mock implementation of reconcilers.Reconciler.
//
//	func TestSomethingThatUsesReconciler(t *testing.T) {
//
//		// make and configure a mocked reconcilers.Reconciler
//		mockedReconciler := &ReconcilerMock{
//			ReconcileFunc: func(ctx context.Context, p reconcilers.Processor) error {
//				panic("mock out the Reconcile method")
//			},
//		}
//
//		// use mockedReconciler in code that requires reconcilers.Reconciler
//		// and then make assertions.
//
//	}
type ReconcilerMock struct {
	// ReconcileFunc mocks the Reconcile method.
	ReconcileFunc func(ctx context.Context, p reconcilers.Processor) error

	// calls tracks calls to the methods.
	calls struct {
		// Reconcile holds details about calls to the Reconcile method.
		Reconcile []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// P is the p argument value.
			P reconcilers.Processor
		}
	}
	lockReconcile sync.RWMutex
}

// Reconcile calls ReconcileFunc.
func (mock *ReconcilerMock) Reconcile(ctx context.Context, p reconcilers.Processor) error {
	if mock.ReconcileFunc == nil {
		panic("ReconcilerMock.ReconcileFunc: method is nil but Reconciler.Reconcile was just called")
	}
	callInfo := struct {
		Ctx context.Context
		P   reconcilers.Processor
	}{
		Ctx: ctx,
		P:   p,
	}
	mock.lockReconcile.Lock()
	mock.calls.Reconcile = append(mock.calls.Reconcile, callInfo)
	mock.lockReconcile.Unlock()
	return mock.ReconcileFunc(ctx, p)
}

// ReconcileCalls gets all the calls that were made to Reconcile.
// Check the length with:
//
//	len(mockedReconciler.ReconcileCalls())
func (mock *ReconcilerMock) ReconcileCalls() []struct {
	Ctx context.Context
	P   reconcilers.Processor
} {
	var calls []struct {
		Ctx context.Context
		P   reconcilers.Processor
	}
	mock.lockReconcile.RLock()
	calls = mock.calls.Reconcile
	mock.lockReconcile.RUnlock()
	return calls
}
