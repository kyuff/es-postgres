// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package eventsio_test

import (
	"context"
	"github.com/jackc/pgx/v5"
	"github.com/kyuff/es"
	"github.com/kyuff/es-postgres/internal/dbtx"
	"github.com/kyuff/es-postgres/internal/eventsio"
	"iter"
	"sync"
)

// Ensure, that SchemaMock does implement eventsio.Schema.
// If this is not the case, regenerate this file with moq.
var _ eventsio.Schema = &SchemaMock{}

// SchemaMock is a mock implementation of eventsio.Schema.
//
//	func TestSomethingThatUsesSchema(t *testing.T) {
//
//		// make and configure a mocked eventsio.Schema
//		mockedSchema := &SchemaMock{
//			InsertOutboxFunc: func(ctx context.Context, tx dbtx.DBTX, streamType string, streamID string, storeStreamID string, eventNumber int64, watermark int64, partition uint32) (int64, error) {
//				panic("mock out the InsertOutbox method")
//			},
//			SelectEventsFunc: func(ctx context.Context, db dbtx.DBTX, streamType string, streamID string, eventNumber int64) (pgx.Rows, error) {
//				panic("mock out the SelectEvents method")
//			},
//			UpdateOutboxFunc: func(ctx context.Context, tx dbtx.DBTX, streamType string, streamID string, eventNumber int64, lastEventNumber int64) (int64, error) {
//				panic("mock out the UpdateOutbox method")
//			},
//			WriteEventFunc: func(ctx context.Context, db dbtx.DBTX, event es.Event, content []byte, metadata []byte) error {
//				panic("mock out the WriteEvent method")
//			},
//		}
//
//		// use mockedSchema in code that requires eventsio.Schema
//		// and then make assertions.
//
//	}
type SchemaMock struct {
	// InsertOutboxFunc mocks the InsertOutbox method.
	InsertOutboxFunc func(ctx context.Context, tx dbtx.DBTX, streamType string, streamID string, storeStreamID string, eventNumber int64, watermark int64, partition uint32) (int64, error)

	// SelectEventsFunc mocks the SelectEvents method.
	SelectEventsFunc func(ctx context.Context, db dbtx.DBTX, streamType string, streamID string, eventNumber int64) (pgx.Rows, error)

	// UpdateOutboxFunc mocks the UpdateOutbox method.
	UpdateOutboxFunc func(ctx context.Context, tx dbtx.DBTX, streamType string, streamID string, eventNumber int64, lastEventNumber int64) (int64, error)

	// WriteEventFunc mocks the WriteEvent method.
	WriteEventFunc func(ctx context.Context, db dbtx.DBTX, event es.Event, content []byte, metadata []byte) error

	// calls tracks calls to the methods.
	calls struct {
		// InsertOutbox holds details about calls to the InsertOutbox method.
		InsertOutbox []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx dbtx.DBTX
			// StreamType is the streamType argument value.
			StreamType string
			// StreamID is the streamID argument value.
			StreamID string
			// StoreStreamID is the storeStreamID argument value.
			StoreStreamID string
			// EventNumber is the eventNumber argument value.
			EventNumber int64
			// Watermark is the watermark argument value.
			Watermark int64
			// Partition is the partition argument value.
			Partition uint32
		}
		// SelectEvents holds details about calls to the SelectEvents method.
		SelectEvents []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db dbtx.DBTX
			// StreamType is the streamType argument value.
			StreamType string
			// StreamID is the streamID argument value.
			StreamID string
			// EventNumber is the eventNumber argument value.
			EventNumber int64
		}
		// UpdateOutbox holds details about calls to the UpdateOutbox method.
		UpdateOutbox []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx dbtx.DBTX
			// StreamType is the streamType argument value.
			StreamType string
			// StreamID is the streamID argument value.
			StreamID string
			// EventNumber is the eventNumber argument value.
			EventNumber int64
			// LastEventNumber is the lastEventNumber argument value.
			LastEventNumber int64
		}
		// WriteEvent holds details about calls to the WriteEvent method.
		WriteEvent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db dbtx.DBTX
			// Event is the event argument value.
			Event es.Event
			// Content is the content argument value.
			Content []byte
			// Metadata is the metadata argument value.
			Metadata []byte
		}
	}
	lockInsertOutbox sync.RWMutex
	lockSelectEvents sync.RWMutex
	lockUpdateOutbox sync.RWMutex
	lockWriteEvent   sync.RWMutex
}

// InsertOutbox calls InsertOutboxFunc.
func (mock *SchemaMock) InsertOutbox(ctx context.Context, tx dbtx.DBTX, streamType string, streamID string, storeStreamID string, eventNumber int64, watermark int64, partition uint32) (int64, error) {
	if mock.InsertOutboxFunc == nil {
		panic("SchemaMock.InsertOutboxFunc: method is nil but Schema.InsertOutbox was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Tx            dbtx.DBTX
		StreamType    string
		StreamID      string
		StoreStreamID string
		EventNumber   int64
		Watermark     int64
		Partition     uint32
	}{
		Ctx:           ctx,
		Tx:            tx,
		StreamType:    streamType,
		StreamID:      streamID,
		StoreStreamID: storeStreamID,
		EventNumber:   eventNumber,
		Watermark:     watermark,
		Partition:     partition,
	}
	mock.lockInsertOutbox.Lock()
	mock.calls.InsertOutbox = append(mock.calls.InsertOutbox, callInfo)
	mock.lockInsertOutbox.Unlock()
	return mock.InsertOutboxFunc(ctx, tx, streamType, streamID, storeStreamID, eventNumber, watermark, partition)
}

// InsertOutboxCalls gets all the calls that were made to InsertOutbox.
// Check the length with:
//
//	len(mockedSchema.InsertOutboxCalls())
func (mock *SchemaMock) InsertOutboxCalls() []struct {
	Ctx           context.Context
	Tx            dbtx.DBTX
	StreamType    string
	StreamID      string
	StoreStreamID string
	EventNumber   int64
	Watermark     int64
	Partition     uint32
} {
	var calls []struct {
		Ctx           context.Context
		Tx            dbtx.DBTX
		StreamType    string
		StreamID      string
		StoreStreamID string
		EventNumber   int64
		Watermark     int64
		Partition     uint32
	}
	mock.lockInsertOutbox.RLock()
	calls = mock.calls.InsertOutbox
	mock.lockInsertOutbox.RUnlock()
	return calls
}

// SelectEvents calls SelectEventsFunc.
func (mock *SchemaMock) SelectEvents(ctx context.Context, db dbtx.DBTX, streamType string, streamID string, eventNumber int64) (pgx.Rows, error) {
	if mock.SelectEventsFunc == nil {
		panic("SchemaMock.SelectEventsFunc: method is nil but Schema.SelectEvents was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Db          dbtx.DBTX
		StreamType  string
		StreamID    string
		EventNumber int64
	}{
		Ctx:         ctx,
		Db:          db,
		StreamType:  streamType,
		StreamID:    streamID,
		EventNumber: eventNumber,
	}
	mock.lockSelectEvents.Lock()
	mock.calls.SelectEvents = append(mock.calls.SelectEvents, callInfo)
	mock.lockSelectEvents.Unlock()
	return mock.SelectEventsFunc(ctx, db, streamType, streamID, eventNumber)
}

// SelectEventsCalls gets all the calls that were made to SelectEvents.
// Check the length with:
//
//	len(mockedSchema.SelectEventsCalls())
func (mock *SchemaMock) SelectEventsCalls() []struct {
	Ctx         context.Context
	Db          dbtx.DBTX
	StreamType  string
	StreamID    string
	EventNumber int64
} {
	var calls []struct {
		Ctx         context.Context
		Db          dbtx.DBTX
		StreamType  string
		StreamID    string
		EventNumber int64
	}
	mock.lockSelectEvents.RLock()
	calls = mock.calls.SelectEvents
	mock.lockSelectEvents.RUnlock()
	return calls
}

// UpdateOutbox calls UpdateOutboxFunc.
func (mock *SchemaMock) UpdateOutbox(ctx context.Context, tx dbtx.DBTX, streamType string, streamID string, eventNumber int64, lastEventNumber int64) (int64, error) {
	if mock.UpdateOutboxFunc == nil {
		panic("SchemaMock.UpdateOutboxFunc: method is nil but Schema.UpdateOutbox was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Tx              dbtx.DBTX
		StreamType      string
		StreamID        string
		EventNumber     int64
		LastEventNumber int64
	}{
		Ctx:             ctx,
		Tx:              tx,
		StreamType:      streamType,
		StreamID:        streamID,
		EventNumber:     eventNumber,
		LastEventNumber: lastEventNumber,
	}
	mock.lockUpdateOutbox.Lock()
	mock.calls.UpdateOutbox = append(mock.calls.UpdateOutbox, callInfo)
	mock.lockUpdateOutbox.Unlock()
	return mock.UpdateOutboxFunc(ctx, tx, streamType, streamID, eventNumber, lastEventNumber)
}

// UpdateOutboxCalls gets all the calls that were made to UpdateOutbox.
// Check the length with:
//
//	len(mockedSchema.UpdateOutboxCalls())
func (mock *SchemaMock) UpdateOutboxCalls() []struct {
	Ctx             context.Context
	Tx              dbtx.DBTX
	StreamType      string
	StreamID        string
	EventNumber     int64
	LastEventNumber int64
} {
	var calls []struct {
		Ctx             context.Context
		Tx              dbtx.DBTX
		StreamType      string
		StreamID        string
		EventNumber     int64
		LastEventNumber int64
	}
	mock.lockUpdateOutbox.RLock()
	calls = mock.calls.UpdateOutbox
	mock.lockUpdateOutbox.RUnlock()
	return calls
}

// WriteEvent calls WriteEventFunc.
func (mock *SchemaMock) WriteEvent(ctx context.Context, db dbtx.DBTX, event es.Event, content []byte, metadata []byte) error {
	if mock.WriteEventFunc == nil {
		panic("SchemaMock.WriteEventFunc: method is nil but Schema.WriteEvent was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Db       dbtx.DBTX
		Event    es.Event
		Content  []byte
		Metadata []byte
	}{
		Ctx:      ctx,
		Db:       db,
		Event:    event,
		Content:  content,
		Metadata: metadata,
	}
	mock.lockWriteEvent.Lock()
	mock.calls.WriteEvent = append(mock.calls.WriteEvent, callInfo)
	mock.lockWriteEvent.Unlock()
	return mock.WriteEventFunc(ctx, db, event, content, metadata)
}

// WriteEventCalls gets all the calls that were made to WriteEvent.
// Check the length with:
//
//	len(mockedSchema.WriteEventCalls())
func (mock *SchemaMock) WriteEventCalls() []struct {
	Ctx      context.Context
	Db       dbtx.DBTX
	Event    es.Event
	Content  []byte
	Metadata []byte
} {
	var calls []struct {
		Ctx      context.Context
		Db       dbtx.DBTX
		Event    es.Event
		Content  []byte
		Metadata []byte
	}
	mock.lockWriteEvent.RLock()
	calls = mock.calls.WriteEvent
	mock.lockWriteEvent.RUnlock()
	return calls
}

// Ensure, that ValidatorMock does implement eventsio.Validator.
// If this is not the case, regenerate this file with moq.
var _ eventsio.Validator = &ValidatorMock{}

// ValidatorMock is a mock implementation of eventsio.Validator.
//
//	func TestSomethingThatUsesValidator(t *testing.T) {
//
//		// make and configure a mocked eventsio.Validator
//		mockedValidator := &ValidatorMock{
//			ValidateFunc: func(streamType string, events iter.Seq2[es.Event, error]) iter.Seq2[es.Event, error] {
//				panic("mock out the Validate method")
//			},
//		}
//
//		// use mockedValidator in code that requires eventsio.Validator
//		// and then make assertions.
//
//	}
type ValidatorMock struct {
	// ValidateFunc mocks the Validate method.
	ValidateFunc func(streamType string, events iter.Seq2[es.Event, error]) iter.Seq2[es.Event, error]

	// calls tracks calls to the methods.
	calls struct {
		// Validate holds details about calls to the Validate method.
		Validate []struct {
			// StreamType is the streamType argument value.
			StreamType string
			// Events is the events argument value.
			Events iter.Seq2[es.Event, error]
		}
	}
	lockValidate sync.RWMutex
}

// Validate calls ValidateFunc.
func (mock *ValidatorMock) Validate(streamType string, events iter.Seq2[es.Event, error]) iter.Seq2[es.Event, error] {
	if mock.ValidateFunc == nil {
		panic("ValidatorMock.ValidateFunc: method is nil but Validator.Validate was just called")
	}
	callInfo := struct {
		StreamType string
		Events     iter.Seq2[es.Event, error]
	}{
		StreamType: streamType,
		Events:     events,
	}
	mock.lockValidate.Lock()
	mock.calls.Validate = append(mock.calls.Validate, callInfo)
	mock.lockValidate.Unlock()
	return mock.ValidateFunc(streamType, events)
}

// ValidateCalls gets all the calls that were made to Validate.
// Check the length with:
//
//	len(mockedValidator.ValidateCalls())
func (mock *ValidatorMock) ValidateCalls() []struct {
	StreamType string
	Events     iter.Seq2[es.Event, error]
} {
	var calls []struct {
		StreamType string
		Events     iter.Seq2[es.Event, error]
	}
	mock.lockValidate.RLock()
	calls = mock.calls.Validate
	mock.lockValidate.RUnlock()
	return calls
}

// Ensure, that CodecMock does implement eventsio.Codec.
// If this is not the case, regenerate this file with moq.
var _ eventsio.Codec = &CodecMock{}

// CodecMock is a mock implementation of eventsio.Codec.
//
//	func TestSomethingThatUsesCodec(t *testing.T) {
//
//		// make and configure a mocked eventsio.Codec
//		mockedCodec := &CodecMock{
//			DecodeFunc: func(streamType string, contentName string, b []byte) (es.Content, error) {
//				panic("mock out the Decode method")
//			},
//			EncodeFunc: func(event es.Event) ([]byte, error) {
//				panic("mock out the Encode method")
//			},
//			RegisterFunc: func(streamType string, contentTypes ...es.Content) error {
//				panic("mock out the Register method")
//			},
//		}
//
//		// use mockedCodec in code that requires eventsio.Codec
//		// and then make assertions.
//
//	}
type CodecMock struct {
	// DecodeFunc mocks the Decode method.
	DecodeFunc func(streamType string, contentName string, b []byte) (es.Content, error)

	// EncodeFunc mocks the Encode method.
	EncodeFunc func(event es.Event) ([]byte, error)

	// RegisterFunc mocks the Register method.
	RegisterFunc func(streamType string, contentTypes ...es.Content) error

	// calls tracks calls to the methods.
	calls struct {
		// Decode holds details about calls to the Decode method.
		Decode []struct {
			// StreamType is the streamType argument value.
			StreamType string
			// ContentName is the contentName argument value.
			ContentName string
			// B is the b argument value.
			B []byte
		}
		// Encode holds details about calls to the Encode method.
		Encode []struct {
			// Event is the event argument value.
			Event es.Event
		}
		// Register holds details about calls to the Register method.
		Register []struct {
			// StreamType is the streamType argument value.
			StreamType string
			// ContentTypes is the contentTypes argument value.
			ContentTypes []es.Content
		}
	}
	lockDecode   sync.RWMutex
	lockEncode   sync.RWMutex
	lockRegister sync.RWMutex
}

// Decode calls DecodeFunc.
func (mock *CodecMock) Decode(streamType string, contentName string, b []byte) (es.Content, error) {
	if mock.DecodeFunc == nil {
		panic("CodecMock.DecodeFunc: method is nil but Codec.Decode was just called")
	}
	callInfo := struct {
		StreamType  string
		ContentName string
		B           []byte
	}{
		StreamType:  streamType,
		ContentName: contentName,
		B:           b,
	}
	mock.lockDecode.Lock()
	mock.calls.Decode = append(mock.calls.Decode, callInfo)
	mock.lockDecode.Unlock()
	return mock.DecodeFunc(streamType, contentName, b)
}

// DecodeCalls gets all the calls that were made to Decode.
// Check the length with:
//
//	len(mockedCodec.DecodeCalls())
func (mock *CodecMock) DecodeCalls() []struct {
	StreamType  string
	ContentName string
	B           []byte
} {
	var calls []struct {
		StreamType  string
		ContentName string
		B           []byte
	}
	mock.lockDecode.RLock()
	calls = mock.calls.Decode
	mock.lockDecode.RUnlock()
	return calls
}

// Encode calls EncodeFunc.
func (mock *CodecMock) Encode(event es.Event) ([]byte, error) {
	if mock.EncodeFunc == nil {
		panic("CodecMock.EncodeFunc: method is nil but Codec.Encode was just called")
	}
	callInfo := struct {
		Event es.Event
	}{
		Event: event,
	}
	mock.lockEncode.Lock()
	mock.calls.Encode = append(mock.calls.Encode, callInfo)
	mock.lockEncode.Unlock()
	return mock.EncodeFunc(event)
}

// EncodeCalls gets all the calls that were made to Encode.
// Check the length with:
//
//	len(mockedCodec.EncodeCalls())
func (mock *CodecMock) EncodeCalls() []struct {
	Event es.Event
} {
	var calls []struct {
		Event es.Event
	}
	mock.lockEncode.RLock()
	calls = mock.calls.Encode
	mock.lockEncode.RUnlock()
	return calls
}

// Register calls RegisterFunc.
func (mock *CodecMock) Register(streamType string, contentTypes ...es.Content) error {
	if mock.RegisterFunc == nil {
		panic("CodecMock.RegisterFunc: method is nil but Codec.Register was just called")
	}
	callInfo := struct {
		StreamType   string
		ContentTypes []es.Content
	}{
		StreamType:   streamType,
		ContentTypes: contentTypes,
	}
	mock.lockRegister.Lock()
	mock.calls.Register = append(mock.calls.Register, callInfo)
	mock.lockRegister.Unlock()
	return mock.RegisterFunc(streamType, contentTypes...)
}

// RegisterCalls gets all the calls that were made to Register.
// Check the length with:
//
//	len(mockedCodec.RegisterCalls())
func (mock *CodecMock) RegisterCalls() []struct {
	StreamType   string
	ContentTypes []es.Content
} {
	var calls []struct {
		StreamType   string
		ContentTypes []es.Content
	}
	mock.lockRegister.RLock()
	calls = mock.calls.Register
	mock.lockRegister.RUnlock()
	return calls
}
