// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package eventsio_test

import (
	"context"
	"github.com/jackc/pgx/v5"
	"github.com/kyuff/es"
	"github.com/kyuff/es-postgres/internal/database"
	"github.com/kyuff/es-postgres/internal/eventsio"
	"iter"
	"sync"
)

// Ensure, that SchemaMock does implement eventsio.Schema.
// If this is not the case, regenerate this file with moq.
var _ eventsio.Schema = &SchemaMock{}

// SchemaMock is a mock implementation of eventsio.Schema.
//
//	func TestSomethingThatUsesSchema(t *testing.T) {
//
//		// make and configure a mocked eventsio.Schema
//		mockedSchema := &SchemaMock{
//			InsertOutboxFunc: func(ctx context.Context, tx database.DBTX, streamType string, streamID string, storeStreamID string, eventNumber int64, watermark int64, partition uint32) (int64, error) {
//				panic("mock out the InsertOutbox method")
//			},
//			SelectEventsFunc: func(ctx context.Context, db database.DBTX, streamType string, streamID string, eventNumber int64) (pgx.Rows, error) {
//				panic("mock out the SelectEvents method")
//			},
//			UpdateOutboxFunc: func(ctx context.Context, tx database.DBTX, streamType string, streamID string, eventNumber int64, lastEventNumber int64) (int64, error) {
//				panic("mock out the UpdateOutbox method")
//			},
//			WriteEventFunc: func(ctx context.Context, db database.DBTX, event es.Event) error {
//				panic("mock out the WriteEvent method")
//			},
//		}
//
//		// use mockedSchema in code that requires eventsio.Schema
//		// and then make assertions.
//
//	}
type SchemaMock struct {
	// InsertOutboxFunc mocks the InsertOutbox method.
	InsertOutboxFunc func(ctx context.Context, tx database.DBTX, streamType string, streamID string, storeStreamID string, eventNumber int64, watermark int64, partition uint32) (int64, error)

	// SelectEventsFunc mocks the SelectEvents method.
	SelectEventsFunc func(ctx context.Context, db database.DBTX, streamType string, streamID string, eventNumber int64) (pgx.Rows, error)

	// UpdateOutboxFunc mocks the UpdateOutbox method.
	UpdateOutboxFunc func(ctx context.Context, tx database.DBTX, streamType string, streamID string, eventNumber int64, lastEventNumber int64) (int64, error)

	// WriteEventFunc mocks the WriteEvent method.
	WriteEventFunc func(ctx context.Context, db database.DBTX, event es.Event) error

	// calls tracks calls to the methods.
	calls struct {
		// InsertOutbox holds details about calls to the InsertOutbox method.
		InsertOutbox []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx database.DBTX
			// StreamType is the streamType argument value.
			StreamType string
			// StreamID is the streamID argument value.
			StreamID string
			// StoreStreamID is the storeStreamID argument value.
			StoreStreamID string
			// EventNumber is the eventNumber argument value.
			EventNumber int64
			// Watermark is the watermark argument value.
			Watermark int64
			// Partition is the partition argument value.
			Partition uint32
		}
		// SelectEvents holds details about calls to the SelectEvents method.
		SelectEvents []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db database.DBTX
			// StreamType is the streamType argument value.
			StreamType string
			// StreamID is the streamID argument value.
			StreamID string
			// EventNumber is the eventNumber argument value.
			EventNumber int64
		}
		// UpdateOutbox holds details about calls to the UpdateOutbox method.
		UpdateOutbox []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx database.DBTX
			// StreamType is the streamType argument value.
			StreamType string
			// StreamID is the streamID argument value.
			StreamID string
			// EventNumber is the eventNumber argument value.
			EventNumber int64
			// LastEventNumber is the lastEventNumber argument value.
			LastEventNumber int64
		}
		// WriteEvent holds details about calls to the WriteEvent method.
		WriteEvent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db database.DBTX
			// Event is the event argument value.
			Event es.Event
		}
	}
	lockInsertOutbox sync.RWMutex
	lockSelectEvents sync.RWMutex
	lockUpdateOutbox sync.RWMutex
	lockWriteEvent   sync.RWMutex
}

// InsertOutbox calls InsertOutboxFunc.
func (mock *SchemaMock) InsertOutbox(ctx context.Context, tx database.DBTX, streamType string, streamID string, storeStreamID string, eventNumber int64, watermark int64, partition uint32) (int64, error) {
	if mock.InsertOutboxFunc == nil {
		panic("SchemaMock.InsertOutboxFunc: method is nil but Schema.InsertOutbox was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Tx            database.DBTX
		StreamType    string
		StreamID      string
		StoreStreamID string
		EventNumber   int64
		Watermark     int64
		Partition     uint32
	}{
		Ctx:           ctx,
		Tx:            tx,
		StreamType:    streamType,
		StreamID:      streamID,
		StoreStreamID: storeStreamID,
		EventNumber:   eventNumber,
		Watermark:     watermark,
		Partition:     partition,
	}
	mock.lockInsertOutbox.Lock()
	mock.calls.InsertOutbox = append(mock.calls.InsertOutbox, callInfo)
	mock.lockInsertOutbox.Unlock()
	return mock.InsertOutboxFunc(ctx, tx, streamType, streamID, storeStreamID, eventNumber, watermark, partition)
}

// InsertOutboxCalls gets all the calls that were made to InsertOutbox.
// Check the length with:
//
//	len(mockedSchema.InsertOutboxCalls())
func (mock *SchemaMock) InsertOutboxCalls() []struct {
	Ctx           context.Context
	Tx            database.DBTX
	StreamType    string
	StreamID      string
	StoreStreamID string
	EventNumber   int64
	Watermark     int64
	Partition     uint32
} {
	var calls []struct {
		Ctx           context.Context
		Tx            database.DBTX
		StreamType    string
		StreamID      string
		StoreStreamID string
		EventNumber   int64
		Watermark     int64
		Partition     uint32
	}
	mock.lockInsertOutbox.RLock()
	calls = mock.calls.InsertOutbox
	mock.lockInsertOutbox.RUnlock()
	return calls
}

// SelectEvents calls SelectEventsFunc.
func (mock *SchemaMock) SelectEvents(ctx context.Context, db database.DBTX, streamType string, streamID string, eventNumber int64) (pgx.Rows, error) {
	if mock.SelectEventsFunc == nil {
		panic("SchemaMock.SelectEventsFunc: method is nil but Schema.SelectEvents was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Db          database.DBTX
		StreamType  string
		StreamID    string
		EventNumber int64
	}{
		Ctx:         ctx,
		Db:          db,
		StreamType:  streamType,
		StreamID:    streamID,
		EventNumber: eventNumber,
	}
	mock.lockSelectEvents.Lock()
	mock.calls.SelectEvents = append(mock.calls.SelectEvents, callInfo)
	mock.lockSelectEvents.Unlock()
	return mock.SelectEventsFunc(ctx, db, streamType, streamID, eventNumber)
}

// SelectEventsCalls gets all the calls that were made to SelectEvents.
// Check the length with:
//
//	len(mockedSchema.SelectEventsCalls())
func (mock *SchemaMock) SelectEventsCalls() []struct {
	Ctx         context.Context
	Db          database.DBTX
	StreamType  string
	StreamID    string
	EventNumber int64
} {
	var calls []struct {
		Ctx         context.Context
		Db          database.DBTX
		StreamType  string
		StreamID    string
		EventNumber int64
	}
	mock.lockSelectEvents.RLock()
	calls = mock.calls.SelectEvents
	mock.lockSelectEvents.RUnlock()
	return calls
}

// UpdateOutbox calls UpdateOutboxFunc.
func (mock *SchemaMock) UpdateOutbox(ctx context.Context, tx database.DBTX, streamType string, streamID string, eventNumber int64, lastEventNumber int64) (int64, error) {
	if mock.UpdateOutboxFunc == nil {
		panic("SchemaMock.UpdateOutboxFunc: method is nil but Schema.UpdateOutbox was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Tx              database.DBTX
		StreamType      string
		StreamID        string
		EventNumber     int64
		LastEventNumber int64
	}{
		Ctx:             ctx,
		Tx:              tx,
		StreamType:      streamType,
		StreamID:        streamID,
		EventNumber:     eventNumber,
		LastEventNumber: lastEventNumber,
	}
	mock.lockUpdateOutbox.Lock()
	mock.calls.UpdateOutbox = append(mock.calls.UpdateOutbox, callInfo)
	mock.lockUpdateOutbox.Unlock()
	return mock.UpdateOutboxFunc(ctx, tx, streamType, streamID, eventNumber, lastEventNumber)
}

// UpdateOutboxCalls gets all the calls that were made to UpdateOutbox.
// Check the length with:
//
//	len(mockedSchema.UpdateOutboxCalls())
func (mock *SchemaMock) UpdateOutboxCalls() []struct {
	Ctx             context.Context
	Tx              database.DBTX
	StreamType      string
	StreamID        string
	EventNumber     int64
	LastEventNumber int64
} {
	var calls []struct {
		Ctx             context.Context
		Tx              database.DBTX
		StreamType      string
		StreamID        string
		EventNumber     int64
		LastEventNumber int64
	}
	mock.lockUpdateOutbox.RLock()
	calls = mock.calls.UpdateOutbox
	mock.lockUpdateOutbox.RUnlock()
	return calls
}

// WriteEvent calls WriteEventFunc.
func (mock *SchemaMock) WriteEvent(ctx context.Context, db database.DBTX, event es.Event) error {
	if mock.WriteEventFunc == nil {
		panic("SchemaMock.WriteEventFunc: method is nil but Schema.WriteEvent was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Db    database.DBTX
		Event es.Event
	}{
		Ctx:   ctx,
		Db:    db,
		Event: event,
	}
	mock.lockWriteEvent.Lock()
	mock.calls.WriteEvent = append(mock.calls.WriteEvent, callInfo)
	mock.lockWriteEvent.Unlock()
	return mock.WriteEventFunc(ctx, db, event)
}

// WriteEventCalls gets all the calls that were made to WriteEvent.
// Check the length with:
//
//	len(mockedSchema.WriteEventCalls())
func (mock *SchemaMock) WriteEventCalls() []struct {
	Ctx   context.Context
	Db    database.DBTX
	Event es.Event
} {
	var calls []struct {
		Ctx   context.Context
		Db    database.DBTX
		Event es.Event
	}
	mock.lockWriteEvent.RLock()
	calls = mock.calls.WriteEvent
	mock.lockWriteEvent.RUnlock()
	return calls
}

// Ensure, that ValidatorMock does implement eventsio.Validator.
// If this is not the case, regenerate this file with moq.
var _ eventsio.Validator = &ValidatorMock{}

// ValidatorMock is a mock implementation of eventsio.Validator.
//
//	func TestSomethingThatUsesValidator(t *testing.T) {
//
//		// make and configure a mocked eventsio.Validator
//		mockedValidator := &ValidatorMock{
//			ValidateFunc: func(streamType string, events iter.Seq2[es.Event, error]) iter.Seq2[es.Event, error] {
//				panic("mock out the Validate method")
//			},
//		}
//
//		// use mockedValidator in code that requires eventsio.Validator
//		// and then make assertions.
//
//	}
type ValidatorMock struct {
	// ValidateFunc mocks the Validate method.
	ValidateFunc func(streamType string, events iter.Seq2[es.Event, error]) iter.Seq2[es.Event, error]

	// calls tracks calls to the methods.
	calls struct {
		// Validate holds details about calls to the Validate method.
		Validate []struct {
			// StreamType is the streamType argument value.
			StreamType string
			// Events is the events argument value.
			Events iter.Seq2[es.Event, error]
		}
	}
	lockValidate sync.RWMutex
}

// Validate calls ValidateFunc.
func (mock *ValidatorMock) Validate(streamType string, events iter.Seq2[es.Event, error]) iter.Seq2[es.Event, error] {
	if mock.ValidateFunc == nil {
		panic("ValidatorMock.ValidateFunc: method is nil but Validator.Validate was just called")
	}
	callInfo := struct {
		StreamType string
		Events     iter.Seq2[es.Event, error]
	}{
		StreamType: streamType,
		Events:     events,
	}
	mock.lockValidate.Lock()
	mock.calls.Validate = append(mock.calls.Validate, callInfo)
	mock.lockValidate.Unlock()
	return mock.ValidateFunc(streamType, events)
}

// ValidateCalls gets all the calls that were made to Validate.
// Check the length with:
//
//	len(mockedValidator.ValidateCalls())
func (mock *ValidatorMock) ValidateCalls() []struct {
	StreamType string
	Events     iter.Seq2[es.Event, error]
} {
	var calls []struct {
		StreamType string
		Events     iter.Seq2[es.Event, error]
	}
	mock.lockValidate.RLock()
	calls = mock.calls.Validate
	mock.lockValidate.RUnlock()
	return calls
}
