// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package processor_test

import (
	"context"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/kyuff/es"
	"github.com/kyuff/es-postgres/internal/processor"
	"iter"
	"sync"
)

// Ensure, that ConnectorMock does implement processor.Connector.
// If this is not the case, regenerate this file with moq.
var _ processor.Connector = &ConnectorMock{}

// ConnectorMock is a mock implementation of processor.Connector.
//
//	func TestSomethingThatUsesConnector(t *testing.T) {
//
//		// make and configure a mocked processor.Connector
//		mockedConnector := &ConnectorMock{
//			AcquireWriteStreamFunc: func(ctx context.Context, streamType string, streamID string) (*pgxpool.Conn, error) {
//				panic("mock out the AcquireWriteStream method")
//			},
//		}
//
//		// use mockedConnector in code that requires processor.Connector
//		// and then make assertions.
//
//	}
type ConnectorMock struct {
	// AcquireWriteStreamFunc mocks the AcquireWriteStream method.
	AcquireWriteStreamFunc func(ctx context.Context, streamType string, streamID string) (*pgxpool.Conn, error)

	// calls tracks calls to the methods.
	calls struct {
		// AcquireWriteStream holds details about calls to the AcquireWriteStream method.
		AcquireWriteStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// StreamType is the streamType argument value.
			StreamType string
			// StreamID is the streamID argument value.
			StreamID string
		}
	}
	lockAcquireWriteStream sync.RWMutex
}

// AcquireWriteStream calls AcquireWriteStreamFunc.
func (mock *ConnectorMock) AcquireWriteStream(ctx context.Context, streamType string, streamID string) (*pgxpool.Conn, error) {
	if mock.AcquireWriteStreamFunc == nil {
		panic("ConnectorMock.AcquireWriteStreamFunc: method is nil but Connector.AcquireWriteStream was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		StreamType string
		StreamID   string
	}{
		Ctx:        ctx,
		StreamType: streamType,
		StreamID:   streamID,
	}
	mock.lockAcquireWriteStream.Lock()
	mock.calls.AcquireWriteStream = append(mock.calls.AcquireWriteStream, callInfo)
	mock.lockAcquireWriteStream.Unlock()
	return mock.AcquireWriteStreamFunc(ctx, streamType, streamID)
}

// AcquireWriteStreamCalls gets all the calls that were made to AcquireWriteStream.
// Check the length with:
//
//	len(mockedConnector.AcquireWriteStreamCalls())
func (mock *ConnectorMock) AcquireWriteStreamCalls() []struct {
	Ctx        context.Context
	StreamType string
	StreamID   string
} {
	var calls []struct {
		Ctx        context.Context
		StreamType string
		StreamID   string
	}
	mock.lockAcquireWriteStream.RLock()
	calls = mock.calls.AcquireWriteStream
	mock.lockAcquireWriteStream.RUnlock()
	return calls
}

// Ensure, that ReaderMock does implement processor.Reader.
// If this is not the case, regenerate this file with moq.
var _ processor.Reader = &ReaderMock{}

// ReaderMock is a mock implementation of processor.Reader.
//
//	func TestSomethingThatUsesReader(t *testing.T) {
//
//		// make and configure a mocked processor.Reader
//		mockedReader := &ReaderMock{
//			ReadFunc: func(ctx context.Context, streamType string, streamID string, eventNumber int64) iter.Seq2[es.Event, error] {
//				panic("mock out the Read method")
//			},
//		}
//
//		// use mockedReader in code that requires processor.Reader
//		// and then make assertions.
//
//	}
type ReaderMock struct {
	// ReadFunc mocks the Read method.
	ReadFunc func(ctx context.Context, streamType string, streamID string, eventNumber int64) iter.Seq2[es.Event, error]

	// calls tracks calls to the methods.
	calls struct {
		// Read holds details about calls to the Read method.
		Read []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// StreamType is the streamType argument value.
			StreamType string
			// StreamID is the streamID argument value.
			StreamID string
			// EventNumber is the eventNumber argument value.
			EventNumber int64
		}
	}
	lockRead sync.RWMutex
}

// Read calls ReadFunc.
func (mock *ReaderMock) Read(ctx context.Context, streamType string, streamID string, eventNumber int64) iter.Seq2[es.Event, error] {
	if mock.ReadFunc == nil {
		panic("ReaderMock.ReadFunc: method is nil but Reader.Read was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		StreamType  string
		StreamID    string
		EventNumber int64
	}{
		Ctx:         ctx,
		StreamType:  streamType,
		StreamID:    streamID,
		EventNumber: eventNumber,
	}
	mock.lockRead.Lock()
	mock.calls.Read = append(mock.calls.Read, callInfo)
	mock.lockRead.Unlock()
	return mock.ReadFunc(ctx, streamType, streamID, eventNumber)
}

// ReadCalls gets all the calls that were made to Read.
// Check the length with:
//
//	len(mockedReader.ReadCalls())
func (mock *ReaderMock) ReadCalls() []struct {
	Ctx         context.Context
	StreamType  string
	StreamID    string
	EventNumber int64
} {
	var calls []struct {
		Ctx         context.Context
		StreamType  string
		StreamID    string
		EventNumber int64
	}
	mock.lockRead.RLock()
	calls = mock.calls.Read
	mock.lockRead.RUnlock()
	return calls
}
